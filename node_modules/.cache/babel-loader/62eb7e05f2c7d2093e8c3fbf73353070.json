{"ast":null,"code":"import _classCallCheck from \"/Users/monsama/firetable/www/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/monsama/firetable/www/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * Custom module for quilljs to allow user to drag images from their file system into the editor\n * and paste images from clipboard (Works on Chrome, Firefox, Edge, not on Safari)\n * @see https://quilljs.com/blog/building-a-custom-module/\n */\nexport var ImageDrop =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Instantiate the module given a quill instance and any options\n   * @param {Quill} quill\n   * @param {Object} options\n   */\n  function ImageDrop(quill) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ImageDrop);\n\n    // save the quill reference\n    this.quill = quill; // bind handlers to this instance\n\n    this.handleDrop = this.handleDrop.bind(this);\n    this.handlePaste = this.handlePaste.bind(this); // listen for drop and paste events\n\n    this.quill.root.addEventListener('drop', this.handleDrop, false);\n    this.quill.root.addEventListener('paste', this.handlePaste, false);\n  }\n  /**\n   * Handler for drop event to read dropped files from evt.dataTransfer\n   * @param {Event} evt\n   */\n\n\n  _createClass(ImageDrop, [{\n    key: \"handleDrop\",\n    value: function handleDrop(evt) {\n      evt.preventDefault();\n\n      if (evt.dataTransfer && evt.dataTransfer.files && evt.dataTransfer.files.length) {\n        if (document.caretRangeFromPoint) {\n          var selection = document.getSelection();\n          var range = document.caretRangeFromPoint(evt.clientX, evt.clientY);\n\n          if (selection && range) {\n            selection.setBaseAndExtent(range.startContainer, range.startOffset, range.startContainer, range.startOffset);\n          }\n        }\n\n        this.readFiles(evt.dataTransfer.files, this.insert.bind(this));\n      }\n    }\n    /**\n     * Handler for paste event to read pasted files from evt.clipboardData\n     * @param {Event} evt\n     */\n\n  }, {\n    key: \"handlePaste\",\n    value: function handlePaste(evt) {\n      var _this = this;\n\n      if (evt.clipboardData && evt.clipboardData.items && evt.clipboardData.items.length) {\n        this.readFiles(evt.clipboardData.items, function (dataUrl) {\n          var selection = _this.quill.getSelection();\n\n          if (selection) {// we must be in a browser that supports pasting (like Firefox)\n            // so it has already been placed into the editor\n          } else {\n            // otherwise we wait until after the paste when this.quill.getSelection()\n            // will return a valid index\n            setTimeout(function () {\n              return _this.insert(dataUrl);\n            }, 0);\n          }\n        });\n      }\n    }\n    /**\n     * Insert the image into the document at the current cursor position\n     * @param {String} dataUrl  The base64-encoded image URI\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(dataUrl) {\n      var index = (this.quill.getSelection() || {}).index || this.quill.getLength();\n      this.quill.insertEmbed(index, 'image', dataUrl, 'user');\n    }\n    /**\n     * Extract image URIs a list of files from evt.dataTransfer or evt.clipboardData\n     * @param {File[]} files  One or more File objects\n     * @param {Function} callback  A function to send each data URI to\n     */\n\n  }, {\n    key: \"readFiles\",\n    value: function readFiles(files, callback) {\n      // check each file for an image\n      [].forEach.call(files, function (file) {\n        if (!file.type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp|vnd\\.microsoft\\.icon)/i)) {\n          // file is not an image\n          // Note that some file formats such as psd start with image/* but are not readable\n          return;\n        } // set up file reader\n\n\n        var reader = new FileReader();\n\n        reader.onload = function (evt) {\n          callback(evt.target.result);\n        }; // read the clipboard item or file\n\n\n        var blob = file.getAsFile ? file.getAsFile() : file;\n\n        if (blob instanceof Blob) {\n          reader.readAsDataURL(blob);\n        }\n      });\n    }\n  }]);\n\n  return ImageDrop;\n}();","map":{"version":3,"sources":["/Users/monsama/firetable/www/node_modules/quill-image-drop-module/index.js"],"names":["ImageDrop","quill","options","handleDrop","bind","handlePaste","root","addEventListener","evt","preventDefault","dataTransfer","files","length","document","caretRangeFromPoint","selection","getSelection","range","clientX","clientY","setBaseAndExtent","startContainer","startOffset","readFiles","insert","clipboardData","items","dataUrl","setTimeout","index","getLength","insertEmbed","callback","forEach","call","file","type","match","reader","FileReader","onload","target","result","blob","getAsFile","Blob","readAsDataURL"],"mappings":"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","sourcesContent":["/**\n * Custom module for quilljs to allow user to drag images from their file system into the editor\n * and paste images from clipboard (Works on Chrome, Firefox, Edge, not on Safari)\n * @see https://quilljs.com/blog/building-a-custom-module/\n */\nexport class ImageDrop {\n\n\t/**\n\t * Instantiate the module given a quill instance and any options\n\t * @param {Quill} quill\n\t * @param {Object} options\n\t */\n\tconstructor(quill, options = {}) {\n\t\t// save the quill reference\n\t\tthis.quill = quill;\n\t\t// bind handlers to this instance\n\t\tthis.handleDrop = this.handleDrop.bind(this);\n\t\tthis.handlePaste = this.handlePaste.bind(this);\n\t\t// listen for drop and paste events\n\t\tthis.quill.root.addEventListener('drop', this.handleDrop, false);\n\t\tthis.quill.root.addEventListener('paste', this.handlePaste, false);\n\t}\n\n\t/**\n\t * Handler for drop event to read dropped files from evt.dataTransfer\n\t * @param {Event} evt\n\t */\n\thandleDrop(evt) {\n\t\tevt.preventDefault();\n\t\tif (evt.dataTransfer && evt.dataTransfer.files && evt.dataTransfer.files.length) {\n\t\t\tif (document.caretRangeFromPoint) {\n\t\t\t\tconst selection = document.getSelection();\n\t\t\t\tconst range = document.caretRangeFromPoint(evt.clientX, evt.clientY);\n\t\t\t\tif (selection && range) {\n\t\t\t\t\tselection.setBaseAndExtent(range.startContainer, range.startOffset, range.startContainer, range.startOffset);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.readFiles(evt.dataTransfer.files, this.insert.bind(this));\n\t\t}\n\t}\n\n\t/**\n\t * Handler for paste event to read pasted files from evt.clipboardData\n\t * @param {Event} evt\n\t */\n\thandlePaste(evt) {\n\t\tif (evt.clipboardData && evt.clipboardData.items && evt.clipboardData.items.length) {\n\t\t\tthis.readFiles(evt.clipboardData.items, dataUrl => {\n\t\t\t\tconst selection = this.quill.getSelection();\n\t\t\t\tif (selection) {\n\t\t\t\t\t// we must be in a browser that supports pasting (like Firefox)\n\t\t\t\t\t// so it has already been placed into the editor\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// otherwise we wait until after the paste when this.quill.getSelection()\n\t\t\t\t\t// will return a valid index\n\t\t\t\t\tsetTimeout(() => this.insert(dataUrl), 0);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Insert the image into the document at the current cursor position\n\t * @param {String} dataUrl  The base64-encoded image URI\n\t */\n\tinsert(dataUrl) {\n\t\tconst index = (this.quill.getSelection() || {}).index || this.quill.getLength();\n\t\tthis.quill.insertEmbed(index, 'image', dataUrl, 'user');\n\t}\n\n\t/**\n\t * Extract image URIs a list of files from evt.dataTransfer or evt.clipboardData\n\t * @param {File[]} files  One or more File objects\n\t * @param {Function} callback  A function to send each data URI to\n\t */\n\treadFiles(files, callback) {\n\t\t// check each file for an image\n\t\t[].forEach.call(files, file => {\n\t\t\tif (!file.type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp|vnd\\.microsoft\\.icon)/i)) {\n\t\t\t\t// file is not an image\n\t\t\t\t// Note that some file formats such as psd start with image/* but are not readable\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// set up file reader\n\t\t\tconst reader = new FileReader();\n\t\t\treader.onload = (evt) => {\n\t\t\t\tcallback(evt.target.result);\n\t\t\t};\n\t\t\t// read the clipboard item or file\n\t\t\tconst blob = file.getAsFile ? file.getAsFile() : file;\n\t\t\tif (blob instanceof Blob) {\n\t\t\t\treader.readAsDataURL(blob);\n\t\t\t}\n\t\t});\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}