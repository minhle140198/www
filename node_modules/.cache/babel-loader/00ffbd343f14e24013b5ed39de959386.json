{"ast":null,"code":"import _regeneratorRuntime from\"/Users/monsama/firetable/www/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _slicedToArray from\"/Users/monsama/firetable/www/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _objectSpread from\"/Users/monsama/firetable/www/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{db}from\"../../firebase\";import Button from\"@material-ui/core/Button\";import React,{useEffect,useReducer,useContext}from\"react\";import equals from\"ramda/es/equals\";import firebase from\"firebase/app\";import{algoliaUpdateDoc}from\"../../firebase/callables\";import{SnackContext}from\"../../contexts/snackContext\";var CAP=1000;// safety  paramter sets the  upper limit of number of docs fetched by this hook\nvar tableReducer=function tableReducer(prevState,newProps){return _objectSpread({},prevState,{},newProps);};var tableInitialState={rows:[],prevFilters:null,prevPath:null,prevOrderBy:null,path:null,filters:[],prevLimit:0,limit:20,loading:true,cap:CAP};var useTable=function useTable(initialOverrides){var snackContext=useContext(SnackContext);var _useReducer=useReducer(tableReducer,_objectSpread({},tableInitialState,{},initialOverrides)),_useReducer2=_slicedToArray(_useReducer,2),tableState=_useReducer2[0],tableDispatch=_useReducer2[1];/**  set collection listener\n   *  @param filters\n   *  @param limit max number of docs\n   *  @param orderBy\n   */var getRows=function getRows(filters,limit,orderBy){//unsubscribe from old path\nif(tableState.prevPath&&tableState.path!==tableState.prevPath){tableState.unsubscribe();}//updates previous values\ntableDispatch({prevFilters:filters,prevLimit:limit,prevPath:tableState.path,prevOrderBy:tableState.orderBy,loading:true});var query=db.collection(tableState.path);filters.forEach(function(filter){query=query.where(filter.key,filter.operator,filter.value);});if(orderBy){orderBy.forEach(function(order){query=query.orderBy(order.key,order.direction);});}var unsubscribe=query.limit(limit).onSnapshot(function(snapshot){if(snapshot.docs.length>0){var rows=snapshot.docs.map(function(doc){var data=doc.data();var id=doc.id;var ref=doc.ref;return _objectSpread({},data,{id:id,ref:ref});}).filter(function(doc){return doc.id!==\"_FIRETABLE_\";});//removes schema file\ntableDispatch({rows:rows,loading:false});}else{tableDispatch({rows:[],loading:false});}},function(error){//TODO:callable to create new index\nif(error.message.includes(\"indexes?create_composite=\")){var url=\"https://console.firebase.google.com/project/\".concat(process.env.REACT_APP_FIREBASE_PROJECT_ID,\"/database/firestore/\")+\"indexes?create_composite=\"+error.message.split(\"indexes?create_composite=\")[1];console.log(url);snackContext.open({message:\"needs a new index\",duration:10000,action:React.createElement(Button,{color:\"secondary\",onClick:function onClick(){window.open(url,\"_blank\");}},\"create\")});}});tableDispatch({unsubscribe:unsubscribe});};useEffect(function(){var prevFilters=tableState.prevFilters,filters=tableState.filters,prevLimit=tableState.prevLimit,prevOrderBy=tableState.prevOrderBy,limit=tableState.limit,prevPath=tableState.prevPath,path=tableState.path,orderBy=tableState.orderBy,unsubscribe=tableState.unsubscribe;if(!equals(prevFilters,filters)||prevLimit!==limit||prevPath!==path||prevOrderBy!==orderBy){if(path)getRows(filters,limit,orderBy);}return function(){if(unsubscribe){tableState.unsubscribe();}};},[tableState.filters,tableState.limit,tableState.path,tableState.orderBy]);/**  used deleting row/doc\n   *  @param rowIndex local position\n   *  @param documentId firestore document id\n   */var deleteRow=function deleteRow(rowIndex,documentId){//remove row locally\ntableState.rows.splice(rowIndex,1);tableDispatch({rows:tableState.rows});// delete document\ndb.collection(tableState.path).doc(documentId).delete();};/**  used for setting up the table listener\n   *  @param tableCollection firestore collection path\n   *  @param filters specify filters to be applied to the query\n   */var setTable=function setTable(tableCollection,filters){if(tableCollection!==tableState.path){tableDispatch({path:tableCollection,rows:[]});}if(filters)tableDispatch({filters:filters});};/**  creating new document/row\n   *  @param data(optional: default will create empty row)\n   */var addRow=function addRow(data){var ref;return _regeneratorRuntime.async(function addRow$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _regeneratorRuntime.awrap(db.collection(tableState.path).add(_objectSpread({createdAt:firebase.firestore.FieldValue.serverTimestamp(),updatedAt:firebase.firestore.FieldValue.serverTimestamp()},data)));case 2:ref=_context.sent;if(data){algoliaUpdateDoc({collection:ref.parent.path,id:ref.id,doc:_objectSpread({},data)});}case 4:case\"end\":return _context.stop();}}});};/**  used for incrementing the number of rows fetched\n   *  @param additionalRows number additional rows to be fetched (optional: default is 20)\n   */var moreRows=function moreRows(additionalRows){tableDispatch({limit:tableState.limit+(additionalRows?additionalRows:20)});};var tableActions={deleteRow:deleteRow,setTable:setTable,addRow:addRow,moreRows:moreRows,dispatch:tableDispatch};return[tableState,tableActions];};export default useTable;","map":{"version":3,"sources":["/Users/monsama/firetable/www/src/hooks/useFiretable/useTable.tsx"],"names":["db","Button","React","useEffect","useReducer","useContext","equals","firebase","algoliaUpdateDoc","SnackContext","CAP","tableReducer","prevState","newProps","tableInitialState","rows","prevFilters","prevPath","prevOrderBy","path","filters","prevLimit","limit","loading","cap","useTable","initialOverrides","snackContext","tableState","tableDispatch","getRows","orderBy","unsubscribe","query","collection","forEach","filter","where","key","operator","value","order","direction","onSnapshot","snapshot","docs","length","map","doc","data","id","ref","error","message","includes","url","process","env","REACT_APP_FIREBASE_PROJECT_ID","split","console","log","open","duration","action","window","deleteRow","rowIndex","documentId","splice","delete","setTable","tableCollection","addRow","add","createdAt","firestore","FieldValue","serverTimestamp","updatedAt","parent","moreRows","additionalRows","tableActions","dispatch"],"mappings":"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","sourcesContent":["import { db } from \"../../firebase\";\n\nimport Button from \"@material-ui/core/Button\";\nimport React, { useEffect, useReducer, useContext } from \"react\";\nimport equals from \"ramda/es/equals\";\nimport firebase from \"firebase/app\";\nimport { algoliaUpdateDoc } from \"../../firebase/callables\";\nimport { FireTableFilter, FiretableOrderBy } from \".\";\nimport { SnackContext } from \"../../contexts/snackContext\";\n\nconst CAP = 1000; // safety  paramter sets the  upper limit of number of docs fetched by this hook\n\nconst tableReducer = (prevState: any, newProps: any) => {\n  return { ...prevState, ...newProps };\n};\nconst tableInitialState = {\n  rows: [],\n  prevFilters: null,\n  prevPath: null,\n  prevOrderBy: null,\n  path: null,\n  filters: [],\n  prevLimit: 0,\n  limit: 20,\n  loading: true,\n  cap: CAP,\n};\n\nconst useTable = (initialOverrides: any) => {\n  const snackContext = useContext(SnackContext);\n\n  const [tableState, tableDispatch] = useReducer(tableReducer, {\n    ...tableInitialState,\n    ...initialOverrides,\n  });\n  /**  set collection listener\n   *  @param filters\n   *  @param limit max number of docs\n   *  @param orderBy\n   */\n  const getRows = (\n    filters: {\n      key: string;\n      operator: \"==\" | \"<\" | \">\" | \">=\" | \"<=\";\n      value: string;\n    }[],\n    limit: number,\n    orderBy: FiretableOrderBy\n  ) => {\n    //unsubscribe from old path\n    if (tableState.prevPath && tableState.path !== tableState.prevPath) {\n      tableState.unsubscribe();\n    }\n    //updates previous values\n    tableDispatch({\n      prevFilters: filters,\n      prevLimit: limit,\n      prevPath: tableState.path,\n      prevOrderBy: tableState.orderBy,\n      loading: true,\n    });\n    let query:\n      | firebase.firestore.CollectionReference\n      | firebase.firestore.Query = db.collection(tableState.path);\n\n    filters.forEach(filter => {\n      query = query.where(filter.key, filter.operator, filter.value);\n    });\n    if (orderBy) {\n      orderBy.forEach(order => {\n        query = query.orderBy(order.key, order.direction);\n      });\n    }\n    const unsubscribe = query.limit(limit).onSnapshot(\n      snapshot => {\n        if (snapshot.docs.length > 0) {\n          const rows = snapshot.docs\n            .map(doc => {\n              const data = doc.data();\n              const id = doc.id;\n              const ref = doc.ref;\n\n              return { ...data, id, ref };\n            })\n            .filter(doc => doc.id !== \"_FIRETABLE_\"); //removes schema file\n          tableDispatch({\n            rows,\n            loading: false,\n          });\n        } else {\n          tableDispatch({\n            rows: [],\n            loading: false,\n          });\n        }\n      },\n      (error: Error) => {\n        //TODO:callable to create new index\n        if (error.message.includes(\"indexes?create_composite=\")) {\n          const url =\n            `https://console.firebase.google.com/project/${process.env.REACT_APP_FIREBASE_PROJECT_ID}/database/firestore/` +\n            \"indexes?create_composite=\" +\n            error.message.split(\"indexes?create_composite=\")[1];\n          console.log(url);\n          snackContext.open({\n            message: \"needs a new index\",\n            duration: 10000,\n            action: (\n              <Button\n                color=\"secondary\"\n                onClick={() => {\n                  window.open(url, \"_blank\");\n                }}\n              >\n                create\n              </Button>\n            ),\n          });\n        }\n      }\n    );\n    tableDispatch({ unsubscribe });\n  };\n  useEffect(() => {\n    const {\n      prevFilters,\n      filters,\n      prevLimit,\n      prevOrderBy,\n      limit,\n      prevPath,\n      path,\n      orderBy,\n      unsubscribe,\n    } = tableState;\n    if (\n      !equals(prevFilters, filters) ||\n      prevLimit !== limit ||\n      prevPath !== path ||\n      prevOrderBy !== orderBy\n    ) {\n      if (path) getRows(filters, limit, orderBy);\n    }\n    return () => {\n      if (unsubscribe) {\n        tableState.unsubscribe();\n      }\n    };\n  }, [\n    tableState.filters,\n    tableState.limit,\n    tableState.path,\n    tableState.orderBy,\n  ]);\n  /**  used deleting row/doc\n   *  @param rowIndex local position\n   *  @param documentId firestore document id\n   */\n  const deleteRow = (rowIndex: number, documentId: string) => {\n    //remove row locally\n    tableState.rows.splice(rowIndex, 1);\n    tableDispatch({ rows: tableState.rows });\n    // delete document\n    db.collection(tableState.path)\n      .doc(documentId)\n      .delete();\n  };\n  /**  used for setting up the table listener\n   *  @param tableCollection firestore collection path\n   *  @param filters specify filters to be applied to the query\n   */\n  const setTable = (tableCollection: string, filters?: FireTableFilter) => {\n    if (tableCollection !== tableState.path) {\n      tableDispatch({ path: tableCollection, rows: [] });\n    }\n    if (filters) tableDispatch({ filters });\n  };\n\n  /**  creating new document/row\n   *  @param data(optional: default will create empty row)\n   */\n  const addRow = async (data?: any) => {\n    const ref = await db.collection(tableState.path).add({\n      createdAt: firebase.firestore.FieldValue.serverTimestamp(),\n      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),\n      ...data,\n    });\n    if (data) {\n      algoliaUpdateDoc({\n        collection: ref.parent.path,\n        id: ref.id,\n        doc: { ...data },\n      });\n    }\n  };\n  /**  used for incrementing the number of rows fetched\n   *  @param additionalRows number additional rows to be fetched (optional: default is 20)\n   */\n  const moreRows = (additionalRows?: number) => {\n    tableDispatch({\n      limit: tableState.limit + (additionalRows ? additionalRows : 20),\n    });\n  };\n\n  const tableActions = {\n    deleteRow,\n    setTable,\n    addRow,\n    moreRows,\n    dispatch: tableDispatch,\n  };\n  return [tableState, tableActions];\n};\n\nexport default useTable;\n"]},"metadata":{},"sourceType":"module"}